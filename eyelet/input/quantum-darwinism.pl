% -----------------
% Quantum Darwinism
% -----------------
%
% Quantum Darwinism is a theory proposing that the classical world
% emerges from the quantum world through a natural selection-like
% process, where certain quantum states proliferate by imprinting
% themselves redundantly into the environment, making them observable
% and objective.
%
% # original code generated by ChatGPT
%
% Core Concepts Modeled
% - state(ID, Amplitude, PointerFlag)
% - entangled(State1, State2)
% - decohered(State, Flag)
% - observer(Name)
% - measured(Observer, State)
% - agrees(Observer1, Observer2)
% - disagrees(Observer1, Observer2)
% - evolves_from(NewState, OldState)

:- op(1200, xfx, :+).

:- use_module(library(gensym)).

:- dynamic('urn:example:state'/2).
:- dynamic('urn:example:entangled'/2).
:- dynamic('urn:example:evolves_from'/2).

% --- Initial Quantum States ---
'urn:example:state'([state1, 0.9], true).
'urn:example:state'([state2, 0.4], false).
'urn:example:state'([state3, 0.9], true).
'urn:example:state'([state4, 0.4], false).

% --- Entanglement ---
'urn:example:entangled'(state1, state3).
'urn:example:entangled'(state2, state4).

% --- Symmetric wrapper for entanglement ---
'urn:example:linked'(A, B) :- 'urn:example:entangled'(A, B).
'urn:example:linked'(A, B) :- 'urn:example:entangled'(B, A).

% --- Decoherence: pointer states decohere ---
'urn:example:decohered'(State, true) :-
    'urn:example:state'([State, _], true).

% --- Observers ---
observer(alice).
observer(bob).

% --- Measurements ---
'urn:example:measured'(alice, state1).
'urn:example:measured'(bob, state3).

% --- Amplitude lookup ---
'urn:example:amplitude'(Observer, Amp) :-
    'urn:example:measured'(Observer, State),
    'urn:example:state'([State, Amp], _).

% --- Agreement logic ---
'urn:example:agrees'(O1, O2) :-
    O1 \= O2,
    'urn:example:measured'(O1, S1),
    'urn:example:measured'(O2, S2),
    'urn:example:linked'(S1, S2),
    'urn:example:amplitude'(O1, A),
    'urn:example:amplitude'(O2, A),
    'urn:example:decohered'(S1, true),
    'urn:example:decohered'(S2, true).

'urn:example:agrees'(O1, O2) :-
    O1 \= O2,
    'urn:example:measured'(O1, S1),
    'urn:example:measured'(O2, S2),
    'urn:example:linked'(S1, S2),
    'urn:example:amplitude'(O1, A1),
    'urn:example:amplitude'(O2, A2),
    A1 \= A2.

% === NEW: Quantum State Evolution ===
% 'urn:example:evolve'(+OldState, -NewState).
'urn:example:evolve'(OldState, NewState) :-
    'urn:example:state'([OldState, Amp], Pointer),
    gensym(state, NewState),
    assertz('urn:example:state'([NewState, Amp], Pointer)),
    assertz(evolves_from(NewState, OldState)),
    % propagate entanglement
    forall('urn:example:entangled'(OldState, Other),
           assertz('urn:example:entangled'(NewState, Other))),
    format("% ðŸŒ± New state created: ~w from ~w~n", [NewState, OldState]).

% query
true :+ 'urn:example:evolve'(state1, _).
true :+ retract('urn:example:state'([state3, 0.9], true)), assertz('urn:example:state'([state3, 0.4], true)), 'urn:example:agrees'(alice, bob).
true :+ 'urn:example:measured'(alice, _), 'urn:example:amplitude'(alice, _).
