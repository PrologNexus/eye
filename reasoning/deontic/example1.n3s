@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <urn:example:>.

# set of possible worlds
:w1 a :PossibleWorld.
:w2 a :PossibleWorld.
:w3 a :PossibleWorld.
:w4 a :PossibleWorld.

# set of propositions
:p1 a :Proposition.
:p2 a :Proposition.
:p3 a :Proposition.
:p4 a :Proposition.

# accessibility relations between worlds
:w1 :hasAccessTo :w2.
:w1 :hasAccessTo :w3.
:w2 :hasAccessTo :w3.

# propositions that are true in possible worlds
:p1 :holdsIn :w1.
:p1 :holdsIn :w2.
:p2 :holdsIn :w2.
:p1 :holdsIn :w3.
(:not :p3) :holdsIn :w3.

# proposition implications
:p1 :implies :p4.

# accessibility is reflexive
(_:World) log:onNegativeSurface {
    _:World a :PossibleWorld.
    () log:onNegativeSurface {
        _:World :hasAccessTo _:World.
    }.
}.

# accessibility is transitive
(_:World1 _:World2_:World3) log:onNegativeSurface {
    _:World1 :hasAccessTo _:World2.
    _:World2 :hasAccessTo _:World3.
    () log:onNegativeSurface {
        _:World1 :hasAccessTo _:World3.
    }.
}.

# a proposition P is obligatory in world W if P holds in all worlds accessible from W
(_:Proposition _:World _:AccessibleWorld _:Scope) log:onNegativeSurface {
    _:Proposition a :Proposition.
    _:World a :PossibleWorld.
    ({ _:World :hasAccessTo _:AccessibleWorld } { _:Proposition :holdsIn _:AccessibleWorld }) log:forAllIn _:Scope.
    () log:onNegativeSurface {
        _:Proposition :isObligatoryIn _:World.
    }.
}.

# a proposition P is permitted in world W if P holds in at least one world accessible from W
(_:Proposition _:World _:AccessibleWorld) log:onNegativeSurface {
    _:Proposition a :Proposition.
    _:World a :PossibleWorld.
    _:World :hasAccessTo _:AccessibleWorld.
    _:Proposition :holdsIn _:AccessibleWorld.
    () log:onNegativeSurface {
        _:Proposition :isPermittedIn _:World.
    }.
}.

# a proposition P is forbidden in world W if P does not hold in any world accessible from W
(_:Proposition _:World _:AccessibleWorld _:List _:Scope) log:onNegativeSurface {
    _:Proposition a :Proposition.
    _:World a :PossibleWorld.
    ({ _:World :hasAccessTo _:AccessibleWorld } { (:not _:Proposition) :holdsIn _:AccessibleWorld }) log:forAllIn _:Scope.
    () log:onNegativeSurface {
        _:Proposition :isForbiddenIn _:World.
    }.
}.

# K axiom
(_:Proposition1 _:Proposition2 _:World) log:onNegativeSurface {
    _:Proposition1 a :Proposition.
    _:Proposition2 a :Proposition.
    _:World a :PossibleWorld.
    _:Proposition1 :implies _:Proposition2.
    _:Proposition1 :isObligatoryIn _:World.
    () log:onNegativeSurface {
        _:Proposition2 :isObligatoryIn _:World.
    }.
}.

# query
(_:Proposition _:World) log:onNegativeSurface {
    _:Proposition :isObligatoryIn _:World.
    () log:onNegativeAnswerSurface {
        _:Proposition :isObligatoryIn _:World.
    }.
}.

(_:Proposition _:World) log:onNegativeSurface {
    _:Proposition :isPermittedIn _:World.
    () log:onNegativeAnswerSurface {
        _:Proposition :isPermittedIn _:World.
    }.
}.

(_:Proposition _:World) log:onNegativeSurface {
    _:Proposition :isForbiddenIn _:World.
    () log:onNegativeAnswerSurface {
        _:Proposition :isForbiddenIn _:World.
    }.
}.
