@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <urn:example:>.

# set of possible worlds
:w1 a :PossibleWorld.
:w2 a :PossibleWorld.
:w3 a :PossibleWorld.

# set of propositions
:p a :Proposition.
:q a :Proposition.

# accessibility relations between worlds
:w1 :hasAccessTo :w2.
:w1 :hasAccessTo :w3.
:w2 :hasAccessTo :w3.

# propositions that are true in possible worlds
:p :isTrueIn :w1.
:p :isTrueIn :w2.
:q :isTrueIn :w2.
:p :isTrueIn :w3.

# proposition implications
:p :implies :r.

# accessibility is reflexive
(_:World) log:onNegativeSurface {
    _:World a :PossibleWorld.
    () log:onNegativeSurface {
        _:World :hasAccessTo _:World.
    }.
}.

# accessibility is transitive
(_:World1 _:World2_:World3) log:onNegativeSurface {
    _:World1 :hasAccessTo _:World2.
    _:World2 :hasAccessTo _:World3.
    () log:onNegativeSurface {
        _:World1 :hasAccessTo _:World3.
    }.
}.

# a proposition P is obligatory in world W if P holds in all worlds accessible from W
(_:Proposition _:World _:AccessibleWorld _:List _:Scope) log:onNegativeSurface {
    _:World a :PossibleWorld.
    _:Proposition a :Proposition.
    (   1
        {
            _:World :hasAccessTo _:AccessibleWorld.
            _:Proposition :isTrueIn _:AccessibleWorld.
        }
        _:List
    ) log:collectAllIn _:Scope.
    (   1
        {
            _:World :hasAccessTo _:AccessibleWorld.
        }
        _:List
    ) log:collectAllIn _:Scope.
    () log:onNegativeSurface {
        _:Proposition :isObligatoryIn _:World.
    }.
}.

# a proposition P is permitted in world W if P holds in at least one world accessible from W
(_:Proposition _:World _:AccessibleWorld) log:onNegativeSurface {
    _:World a :PossibleWorld.
    _:Proposition a :Proposition.
    _:World :hasAccessTo _:AccessibleWorld.
    _:Proposition :isTrueIn _:AccessibleWorld.
    () log:onNegativeSurface {
        _:Proposition :isPermittedIn _:World.
    }.
}.

# a proposition P is forbidden in world W if P does not hold in any world accessible from W
(_:Proposition _:World _:AccessibleWorld _:List _:Scope) log:onNegativeSurface {
    _:World a :PossibleWorld.
    _:Proposition a :Proposition.
    (   1
        {
            _:World :hasAccessTo _:AccessibleWorld.
            _:Scope log:notIncludes {
                _:Proposition :isTrueIn _:AccessibleWorld.
            }
        }
        _:List
    ) log:collectAllIn _:Scope.
    (   1
        {
            _:World :hasAccessTo _:AccessibleWorld.
        }
        _:List
    ) log:collectAllIn _:Scope.
    () log:onNegativeSurface {
        _:Proposition :isForbiddenIn _:World.
    }.
}.

# K axiom
(_:Proposition1 _:Proposition2 _:World) log:onNegativeSurface {
    _:Proposition1 :implies _:Proposition2.
    _:Proposition1 :isObligatoryIn _:World.
    () log:onNegativeSurface {
        _:Proposition2 :isObligatoryIn _:World.
    }.
}.

# query
(_:Proposition _:World) log:onNegativeSurface {
    _:Proposition :isObligatoryIn _:World.
    () log:onNegativeAnswerSurface {
        _:Proposition :isObligatoryIn _:World.
    }.
}.

(_:Proposition _:World) log:onNegativeSurface {
    _:Proposition :isPermittedIn _:World.
    () log:onNegativeAnswerSurface {
        _:Proposition :isPermittedIn _:World.
    }.
}.

(_:Proposition _:World) log:onNegativeSurface {
    _:Proposition :isForbiddenIn _:World.
    () log:onNegativeAnswerSurface {
        _:Proposition :isForbiddenIn _:World.
    }.
}.
