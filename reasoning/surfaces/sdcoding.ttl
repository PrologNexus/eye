# Superdense coding using discrete quantum computing

# See https://arxiv.org/pdf/1101.3764.pdf and https://arxiv.org/pdf/1010.2929.pdf

# Discrete quantum theory is obtained by instantiating the mathematical framework
# of Hilbert spaces with a finite field instead of the field of complex numbers.
# This instantiation collapses much the structure of actual quantum mechanics but
# retains several of its distinguishing characteristics including the notions of
# superposition, interference, and entanglement. Furthermore, discrete quantum
# theory excludes local hidden variable models, has a no-cloning theorem, and can
# express natural counterparts of quantum information protocols such as superdense
# coding and teleportation.

# Surprisingly discrete quantum computing is identical to conventional logic
# programming except for a small twist that is responsible for all the
# "quantum-ness". The twist occurs when merging sets of answers computed by
# several alternatives: the answers are combined using an exclusive version of
# logical disjunction. In other words, the two branches of a choice junction
# exhibit an interference effect: an answer is produced from the junction if it
# occurs in one or the other branch but not both.

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix : <http://example.org/#>.

# |R) = |0, 0) + |1, 1)
[] rdf:value false;  :r false.
[] rdf:value true;  :r true.

# |S) = |0, 1) + |1, 0)
[] rdf:value false;  :s true.
[] rdf:value true;  :s false.

# |U) = |0, 0) + |1, 0) + |1, 1)
[] rdf:value false;  :u false.
[] rdf:value true;  :u false.
[] rdf:value true;  :u true.

# |V ) = |0, 0) + |0, 1) + |1, 0)
[] rdf:value false;  :v false.
[] rdf:value false;  :v true.
[] rdf:value true;  :v false.

# ID |0) = |0)
[] rdf:value false;  :id false.

# ID |1) = |1)
[] rdf:value true;  :id true.

# G |0) = |1)
[] rdf:value false;  :g true.

# G |1) = |0)
[] rdf:value true;  :g false.

# K |0) = |0)
[] rdf:value false;  :k false.

# K |1) = |0) + |1)
[] rdf:value true;  :k false.
[] rdf:value true;  :k true.

# KG
(_:X _:Y _:Z) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        _:X :kg _:Y
    )
    _:X :g _:Z
    _:Z :k _:Y
).

# GK
(_:X _:Y _:Z) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        _:X :gk _:Y
    )
    _:X :k _:Z
    _:Z :g _:Y
).

# Alice
(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        0 :alice (_:X _:Y)
    )
    _:X :id _:Y
).

(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        1 :alice (_:X _:Y)
    )
    _:X :g _:Y
).

(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        2 :alice (_:X _:Y)
    )
    _:X :k _:Y
).

(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        3 :alice (_:X _:Y)
    )
    _:X :kg _:Y
).

# Bob
(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        (_:X _:Y) :bob 0
    )
    _:X :gk _:Y
).

(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        (_:X _:Y) :bob 1
    )
    _:X :k _:Y
).

(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        (_:X _:Y) :bob 2
    )
    _:X :g _:Y
).

(_:X _:Y) log:onNegativeSurface (log:and
    () log:onNegativeComponentSurface (log:and
        (_:X _:Y) :bob 3
    )
    _:X :id _:Y
).

# superdense coding
(_:N _:A _:B _:M _:X _:Y _:Z _:L _:S _:I) log:onNegativeSurface (log:and
    _:N :alice _:A
    _:B :bob _:M
    (
        1
        (log:and
            _:X :r _:Y
            _:N :alice (_:X _:Z)
            (_:Z _:Y) :bob _:M
        )
        _:L
    ) log:collectAllIn _:S
    _:L list:length _:I
    (_:I 2) math:remainder 1
    () log:onNegativeSurface (log:and
        _:N :sdcoding _:M
    )
).

# query
(_:N _:M) log:onQuerySurface (log:and
    _:N :sdcoding _:M
).

