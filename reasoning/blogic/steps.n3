# ----------------------------
# Policy model finding example
# ----------------------------

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix graph: <http://www.w3.org/2000/10/swap/graph#>.
@prefix vcard: <http://www.w3.org/2006/vcard/ns#>.
@prefix : <http://example.org/ns#>.
@prefix skolem: <http://eyereasoner.github.io/.well-known/genid/d7882a29-44b8-4cbc-bc70-3bd11fba1fdb#>.

# Pat is an individual
:Pat a vcard:Individual.

# if X is an individual then X can do A or B
(skolem:X) log:onNegativeSurface {
    skolem:X a vcard:Individual.
    () log:onNegativeSurface {
        skolem:X :canDo :A.
    }.
    () log:onNegativeSurface {
        skolem:X :canDo :B.
    }.
}.

# if X is an individual who can do A then X can do E or D
(skolem:X) log:onNegativeSurface {
    #skolem:X a vcard:Individual.
    skolem:X :canDo :A.
    () log:onNegativeSurface {
        skolem:X :canDo :E.
    }.
    () log:onNegativeSurface {
        skolem:X :canDo :D.
    }.
}.

# if X is an individual who can do D then X can do E or F
(skolem:X) log:onNegativeSurface {
    #skolem:X a vcard:Individual.
    skolem:X :canDo :D.
    () log:onNegativeSurface {
        skolem:X :canDo :E.
    }.
    () log:onNegativeSurface {
        skolem:X :canDo :F.
    }.
}.

# find model reaching goal
(skolem:Goal skolem:Sequents skolem:Model) log:onNegativeSurface {
    () log:onNegativeSurface <<skolem:Goal :findModel (skolem:Sequents skolem:Model skolem:Model)>>.
    skolem:Goal log:callWithCut true.
}.

(skolem:Goal skolem:Sequents1 skolem:Model1 skolem:Model skolem:Prem skolem:Cases skolem:Case skolem:Sequents2 skolem:Model2) log:onNegativeSurface {
    () log:onNegativeSurface <<skolem:Goal :findModel (skolem:Sequents1 skolem:Model1 skolem:Model)>>.
    skolem:Prem => skolem:Cases.
    skolem:Cases list:member skolem:Case.
    skolem:Prem log:call true.
    skolem:Sequents1 list:notMember {skolem:Prem => skolem:Cases}.
    (skolem:Sequents1 ({skolem:Prem => skolem:Cases})) list:append skolem:Sequents2.
    (skolem:Model1 (skolem:Case)) list:append skolem:Model2.
    true log:becomes skolem:Case.
    {
        skolem:Goal :findModel (skolem:Sequents2 skolem:Model2 skolem:Model).
    } log:callWithCleanup {
        skolem:Case log:becomes true.
    }.
}.

# find model where X is an individual who can do E
(skolem:X skolem:Model) log:onQuestionSurface {
    {
        skolem:X a vcard:Individual.
        skolem:X :canDo :E.
    } :findModel (() () skolem:Model).
    () log:onAnswerSurface {
        {
            skolem:X a vcard:Individual.
            skolem:X :canDo :E.
        } :perModel skolem:Model.
    }.
}.
