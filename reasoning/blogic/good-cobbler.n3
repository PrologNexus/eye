# ------------
# Good Cobbler
# ------------
#
# Example from https://shs.hal.science/halshs-04148373/document
# Using functional logic http://intrologic.stanford.edu/chapters/chapter_11.html
#

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix : <urn:example:>.

# Some x is a good cobbler
# (:good :Cobbler) stands for the functional term good(Cobbler)
_:x a (:good :Cobbler).

(:good :Cobbler) rdfs:subClassOf :Cobbler.

# rdfs:subClassOf entailment
(skolem:C skolem:D skolem:X) log:onNegativeSurface {
    skolem:C rdfs:subClassOf skolem:D.
    skolem:X a skolem:C.
    () log:onNegativeSurface {
        skolem:X a skolem:D.
    }.
}.
# invalid inference "x is good. x is a cobbler. therefore, x is a good cobbler".
# uncommenting the following 2 triples will blow a inference fuse
#skolem:x a :good.
#skolem:x a :Cobbler.

# maybe this is too strong in general
(skolem:a skolem:b skolem:c) log:onNegativeSurface {
    skolem:a a skolem:b.
    skolem:a a skolem:c.
    () log:onNegativeSurface {
        () log:onNegativeSurface {
            skolem:a a (skolem:b skolem:c).
        }.
    }.
}.

# some more thinking
# donald is a decoy duck, but it is not a duck

:donald a (:decoy :duck).

(:decoy :duck) rdfs:subClassOf :decoy.

# query
(skolem:S skolem:C) log:onQuerySurface {
    skolem:S a skolem:C.
}.
