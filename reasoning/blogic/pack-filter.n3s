@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix graph: <http://www.w3.org/2000/10/swap/graph#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix : <http://example.org/ns#>.

# sample data from RubenD
() :data {
    () :package {
        << () :content {
            :a :b :c.
            () :package {
                << () :content {
                    :u :v :w.
                    () :package {
                        << () :content {
                            :x :y :z.
                        } >> :usable_until :yesterday.
                    }
                } >> :usable_until :tomorrow.
            }
        } >> :usable_until :next_week.
    }.
}.

# the logic for flatten in 5 backward rules
(_:c _:t _:d _:l _:m) log:onNegativeSurface {
    () log:onNegativeSurface <<
        {
            () :package {
                << () :content _:c >> :usable_until _:t.
            }
        } :filter {
            () :package {
                << () :content _:d >> :usable_until _:t.
            }
        }
    >>.
    (:tomorrow :next_week) list:member _:t.
    _:c graph:list _:l.
    _:l :filter _:m.
    _:m graph:union _:d.
}.

(_:c _:t) log:onNegativeSurface {
    () log:onNegativeSurface <<
        {
            () :package {
                << () :content _:c >> :usable_until _:t.
            }.
        } :filter true
    >>.
    (:yesterday :past_week) list:member _:t.
}.

() log:onNegativeSurface {
    () log:onNegativeSurface << () :filter () >>.
}.

(_:g _:h _:f _:r _:a _:b) log:onNegativeSurface {
    () log:onNegativeSurface << _:g :filter _:h >>.
    _:g list:firstRest (_:f _:r).
    _:h list:firstRest (_:a _:b).
    _:f :filter _:a.
    _:r :filter _:b.
}.

(_:g _:r _:p) log:onNegativeSurface {
    () log:onNegativeSurface << _:g :filter _:g >>.
    _:g log:rawType _:r.
    _:r log:notEqualTo rdf:List.
    _:g log:notIncludes {
        () :package _:p.
    }.
}.

# question
(_:l _:g _:h) log:onQuestionSurface {
    _:l :data _:g.
    _:g :filter _:h.
    () log:onAnswerSurface {
        _:l :filtered_data _:h.
    }.
}.
