# Skolem machine example from http://skolemmachines.org/reports/SkolemMachines.pdf
#
# 2-Counter machine
# Example: R1 + R2 -> R1
# 1: jpz(R2,5,2)
# 2: dec(R2)
# 3: inc(R1)
# 4: goto(1)
# 5: halt

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <http://example.org/ns#>.

# program
1 :instruction (:jpz 2 5 2).
2 :instruction (:dec 2 3 :x).
3 :instruction (:inc 1 4 :x).
4 :instruction (:goto 1 :x :x).
5 :instruction (:halt :x :x :x).

# data
0 :inc 1.
1 :inc 2.
2 :inc 3.
3 :inc 4.
4 :inc 5.
5 :inc 6.
6 :inc 7.
7 :inc 8.
8 :inc 9.
9 :inc 10.

1 :state (3 4). # START compute 3 + 4

# UNIVERSAL INTERPRETATION OF REGISTER INSTRUCTIONS
# :jpz
(_PC _R2 _PA _PB) log:onNegativeSurface {
    _PC :state (0 _R2).
    _PC :instruction (:jpz 1 _PA _PB).
    () log:onNegativeSurface {
        _PA :state (0 _R2).
    }.
}.

(_PC _R1 _R2 _X _PA _PB) log:onNegativeSurface {
    _PC :state (_R1 _R2).
    _X :inc _R1.
    _PC :instruction (:jpz 1 _PA _PB).
    () log:onNegativeSurface {
        _PB :state (_R1 _R2).
    }.
}.

(_PC _R1 _PA _PB) log:onNegativeSurface {
    _PC :state (_R1 0).
    _PC :instruction (:jpz 2 _PA _PB).
    () log:onNegativeSurface {
        _PA :state (_R1 0).
    }.
}.

(_PC _R1 _R2 _X _PA _PB) log:onNegativeSurface {
    _PC :state (_R1 _R2).
    _X :inc _R2.
    _PC :instruction (:jpz 2 _PA _PB).
    () log:onNegativeSurface {
        _PB :state (_R1 _R2).
    }.
}.

# :dec
(_PC _R1 _R2 _D _PB) log:onNegativeSurface {
    _PC :state (_R1 _R2).
    _PC :instruction (:dec 1 _PB :x).
    _D :inc _R1.
    () log:onNegativeSurface {
        _PB :state (_D _R2).
    }.
}.

(_PC _R1 _R2 _D _PB) log:onNegativeSurface {
    _PC :state (_R1 _R2).
    _PC :instruction (:dec 2 _PB :x).
    _D :inc _R2.
    () log:onNegativeSurface {
        _PB :state (_R1 _D).
    }.
}.

# inc
(_PC _R1 _R2 _I _PB) log:onNegativeSurface {
    _PC :state (_R1 _R2).
    _PC :instruction (:inc 1 _PB :x).
    _R1 :inc _I.
    () log:onNegativeSurface {
        _PB :state (_I _R2).
    }.
}.

(_PC _R1 _R2 _I _PB) log:onNegativeSurface {
    _PC :state (_R1 _R2).
    _PC :instruction (:inc 2 _PB :x).
    _R2 :inc _I.
    () log:onNegativeSurface {
        _PB :state (_R1 _I).
    }.
}.

# :goto
(_PC _R1 _R2 _PB) log:onNegativeSurface {
    _PC :state (_R1 _R2).
    _PC :instruction (:goto _PB :x :x).
    () log:onNegativeSurface {
        _PB :state (_R1 _R2).
    }.
}.

# Natural number generation via inc
#(_X _Y) log:onNegativeSurface {
#    _X :inc _Y.
#    (_Z) log:onNegativeSurface {
#        _Y :inc _Z.
#    }.
#}.

# query
(_PC _R1 _R2) log:onQuerySurface {
    _PC :state (_R1 _R2).
    _PC :instruction (:halt :x :x :x).
}.
