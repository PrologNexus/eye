# Skolem machine example from http://skolemmachines.org/reports/SkolemMachines.pdf
#
# 2-Counter machine
# Example: R1 + R2 -> R1
# 1: jpz(R2,5,2)
# 2: dec(R2)
# 3: inc(R1)
# 4: goto(1)
# 5: halt

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <http://example.org/ns#>.

# program
1 :instruction (:jpz 2 5 2).
2 :instruction (:dec 2 3 :x).
3 :instruction (:inc 1 4 :x).
4 :instruction (:goto 1 :x :x).
5 :instruction (:halt :x :x :x).

# data
0 :inc 1.
1 :inc 2.
2 :inc 3.
3 :inc 4.
4 :inc 5.
5 :inc 6.
6 :inc 7.
7 :inc 8.
8 :inc 9.
9 :inc 10.

1 :state (3 4). # START compute 3 + 4

# UNIVERSAL INTERPRETATION OF REGISTER INSTRUCTIONS
# :jpz
(skolem:PC skolem:R2 skolem:PA skolem:PB) log:onNegativeSurface {
    skolem:PC :state (0 skolem:R2).
    skolem:PC :instruction (:jpz 1 skolem:PA skolem:PB).
    () log:onNegativeSurface {
        skolem:PA :state (0 skolem:R2).
    }.
}.

(skolem:PC skolem:R1 skolem:R2 skolem:X skolem:PA skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:X :inc skolem:R1.
    skolem:PC :instruction (:jpz 1 skolem:PA skolem:PB).
    () log:onNegativeSurface {
        skolem:PB :state (skolem:R1 skolem:R2).
    }.
}.

(skolem:PC skolem:R1 skolem:PA skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 0).
    skolem:PC :instruction (:jpz 2 skolem:PA skolem:PB).
    () log:onNegativeSurface {
        skolem:PA :state (skolem:R1 0).
    }.
}.

(skolem:PC skolem:R1 skolem:R2 skolem:X skolem:PA skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:X :inc skolem:R2.
    skolem:PC :instruction (:jpz 2 skolem:PA skolem:PB).
    () log:onNegativeSurface {
        skolem:PB :state (skolem:R1 skolem:R2).
    }.
}.

# :dec
(skolem:PC skolem:R1 skolem:R2 skolem:D skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:PC :instruction (:dec 1 skolem:PB :x).
    skolem:D :inc skolem:R1.
    () log:onNegativeSurface {
        skolem:PB :state (skolem:D skolem:R2).
    }.
}.

(skolem:PC skolem:R1 skolem:R2 skolem:D skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:PC :instruction (:dec 2 skolem:PB :x).
    skolem:D :inc skolem:R2.
    () log:onNegativeSurface {
        skolem:PB :state (skolem:R1 skolem:D).
    }.
}.

# inc
(skolem:PC skolem:R1 skolem:R2 skolem:I skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:PC :instruction (:inc 1 skolem:PB :x).
    skolem:R1 :inc skolem:I.
    () log:onNegativeSurface {
        skolem:PB :state (skolem:I skolem:R2).
    }.
}.

(skolem:PC skolem:R1 skolem:R2 skolem:I skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:PC :instruction (:inc 2 skolem:PB :x).
    skolem:R2 :inc skolem:I.
    () log:onNegativeSurface {
        skolem:PB :state (skolem:R1 skolem:I).
    }.
}.

# :goto
(skolem:PC skolem:R1 skolem:R2 skolem:PB) log:onNegativeSurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:PC :instruction (:goto skolem:PB :x :x).
    () log:onNegativeSurface {
        skolem:PB :state (skolem:R1 skolem:R2).
    }.
}.

# Natural number generation via inc
#(skolem:X skolem:Y) log:onNegativeSurface {
#    skolem:X :inc skolem:Y.
#    (skolem:Z) log:onNegativeSurface {
#        skolem:Y :inc skolem:Z.
#    }.
#}.

# query
(skolem:PC skolem:R1 skolem:R2) log:onQuerySurface {
    skolem:PC :state (skolem:R1 skolem:R2).
    skolem:PC :instruction (:halt :x :x :x).
}.
