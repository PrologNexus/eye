# Skolem machine example from http://skolemmachines.org/reports/SkolemMachines.pdf
#
# 2-Counter machine
# Example: R1 + R2 -> R1
# 1: jpz(R2,5,2)
# 2: dec(R2)
# 3: inc(R1)
# 4: goto(1)
# 5: halt

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <http://example.org/ns#>.

# program
1 :instruction (:jpz 2 5 2).
2 :instruction (:dec 2 3 :x).
3 :instruction (:inc 1 4 :x).
4 :instruction (:goto 1 :x :x).
5 :instruction (:halt :x :x :x).

# data
0 :inc 1.
1 :inc 2.
2 :inc 3.
3 :inc 4.
4 :inc 5.
5 :inc 6.
6 :inc 7.
7 :inc 8.
8 :inc 9.
9 :inc 10.

1 :state (3 4). # START compute 3 + 4

# UNIVERSAL INTERPRETATION OF REGISTER INSTRUCTIONS
# :jpz
(?PC ?R2 ?PA ?PB) log:onNegativeSurface {
    ?PC :state (0 ?R2).
    ?PC :instruction (:jpz 1 ?PA ?PB).
    () log:onNegativeSurface {
        ?PA :state (0 ?R2).
    }.
}.

(?PC ?R1 ?R2 ?X ?PA ?PB) log:onNegativeSurface {
    ?PC :state (?R1 ?R2).
    ?X :inc ?R1.
    ?PC :instruction (:jpz 1 ?PA ?PB).
    () log:onNegativeSurface {
        ?PB :state (?R1 ?R2).
    }.
}.

(?PC ?R1 ?PA ?PB) log:onNegativeSurface {
    ?PC :state (?R1 0).
    ?PC :instruction (:jpz 2 ?PA ?PB).
    () log:onNegativeSurface {
        ?PA :state (?R1 0).
    }.
}.

(?PC ?R1 ?R2 ?X ?PA ?PB) log:onNegativeSurface {
    ?PC :state (?R1 ?R2).
    ?X :inc ?R2.
    ?PC :instruction (:jpz 2 ?PA ?PB).
    () log:onNegativeSurface {
        ?PB :state (?R1 ?R2).
    }.
}.

# :dec
(?PC ?R1 ?R2 ?D ?PB) log:onNegativeSurface {
    ?PC :state (?R1 ?R2).
    ?PC :instruction (:dec 1 ?PB :x).
    ?D :inc ?R1.
    () log:onNegativeSurface {
        ?PB :state (?D ?R2).
    }.
}.

(?PC ?R1 ?R2 ?D ?PB) log:onNegativeSurface {
    ?PC :state (?R1 ?R2).
    ?PC :instruction (:dec 2 ?PB :x).
    ?D :inc ?R2.
    () log:onNegativeSurface {
        ?PB :state (?R1 ?D).
    }.
}.

# inc
(?PC ?R1 ?R2 ?I ?PB) log:onNegativeSurface {
    ?PC :state (?R1 ?R2).
    ?PC :instruction (:inc 1 ?PB :x).
    ?R1 :inc ?I.
    () log:onNegativeSurface {
        ?PB :state (?I ?R2).
    }.
}.

(?PC ?R1 ?R2 ?I ?PB) log:onNegativeSurface {
    ?PC :state (?R1 ?R2).
    ?PC :instruction (:inc 2 ?PB :x).
    ?R2 :inc ?I.
    () log:onNegativeSurface {
        ?PB :state (?R1 ?I).
    }.
}.

# :goto
(?PC ?R1 ?R2 ?PB) log:onNegativeSurface {
    ?PC :state (?R1 ?R2).
    ?PC :instruction (:goto ?PB :x :x).
    () log:onNegativeSurface {
        ?PB :state (?R1 ?R2).
    }.
}.

# Natural number generation via inc
#(?X ?Y) log:onNegativeSurface {
#    ?X :inc ?Y.
#    (?Z) log:onNegativeSurface {
#        ?Y :inc ?Z.
#    }.
#}.

# query
(?PC ?R1 ?R2) log:onQuerySurface {
    ?PC :state (?R1 ?R2).
    ?PC :instruction (:halt :x :x :x).
}.
