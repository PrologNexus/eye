# Goal driven Parallel Sequences -- Jos De Roo

# Inspired by https://www.cs.cmu.edu/~fp/courses/15816-s12/lectures/01-inference.pdf

# "In linear logic we are instead concerned with the change of truth with a
# change of state. We model this in a very simple way: when an inference rule
# is applied we consume the propositions used as premises and produce the
# propositions in the conclusions, thereby effecting an overall change in state."

@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix gps: <http://eyereasoner.github.io/eye/reasoning/gps/gps-schema#>.
@prefix : <http://eyereasoner.github.io/eye/reasoning#>.

# find paths in the state space from initial state to goal state within limits
(?SCOPE ?Goal ?Path ?Duration ?Cost ?Belief ?Comfort ?MaxDuration ?MaxCost ?MinBelief ?MinComfort) log:onNegativeSurface {
    () log:onNegativeSurface <<?SCOPE gps:findpath (?Goal ?Path ?Duration ?Cost ?Belief ?Comfort
            (?MaxDuration ?MaxCost ?MinBelief ?MinComfort))>>.
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path ?Duration ?Cost ?Belief ?Comfort
        (?MaxDuration ?MaxCost ?MinBelief ?MinComfort 1)).
}.

(?SCOPE ?Goal ?Path ?Duration ?Cost ?Belief ?Comfort ?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount) log:onNegativeSurface {
    () log:onNegativeSurface <<?SCOPE gps:findpath (?Goal ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))>>.
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path ?Duration ?Cost ?Belief ?Comfort
        (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount)).
}.

(?SCOPE ?Maps ?Goal ?Path ?Duration ?Cost ?Belief ?Comfort ?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount) log:onNegativeSurface {
    () log:onNegativeSurface <<?SCOPE gps:findpaths (?Maps ?Goal ?Path ?Duration ?Cost ?Belief ?Comfort ?Path ?Duration ?Cost ?Belief ?Comfort
            (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))>>.
    ?Goal log:callWithCleanup true.
}.

(?SCOPE ?Maps_s ?Goal ?Path_s ?Duration_s ?Cost_s ?Belief_s ?Comfort_s ?Path
 ?Duration ?Cost ?Belief ?Comfort ?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount
 ?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n ?Map ?Maps_t ?Stagecount
 ?Duration_t ?Cost_t ?Belief_t ?Comfort_t ?Path_t) log:onNegativeSurface {
    () log:onNegativeSurface <<?SCOPE gps:findpaths (?Maps_s ?Goal ?Path_s ?Duration_s ?Cost_s ?Belief_s ?Comfort_s ?Path ?Duration ?Cost ?Belief ?Comfort
            (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))>>.
    ?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n).
    (?Maps_s (?Map)) list:append ?Maps_t.
    ?Maps_t gps:stagecount ?Stagecount.
    ?Stagecount math:notGreaterThan ?MaxStagecount.
    (?Duration_s ?Duration_n) math:sum ?Duration_t.
    ?Duration_t math:notGreaterThan ?MaxDuration.
    (?Cost_s ?Cost_n) math:sum ?Cost_t.
    ?Cost_t math:notGreaterThan ?MaxCost.
    (?Belief_s ?Belief_n) math:product ?Belief_t.
    ?Belief_t math:notLessThan ?MinBelief.
    (?Comfort_s ?Comfort_n) math:product ?Comfort_t.
    ?Comfort_t math:notLessThan ?MinComfort.
    (?Path_s (?Action)) list:append ?Path_t.
    ?From log:becomes ?To.
    {?SCOPE gps:findpaths (?Maps_t ?Goal ?Path_t ?Duration_t ?Cost_t ?Belief_t ?Comfort_t ?Path ?Duration ?Cost ?Belief ?Comfort
        (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} log:callWithCleanup {?To log:becomes ?From}.
}.

# counting the number of stages (a stage is a sequence of steps in the same map)
() log:onNegativeSurface {
    () log:onNegativeSurface <<() gps:stagecount 1>>.
}.

(?A ?B ?C ?D ?E ?F ?G) log:onNegativeSurface {
    () log:onNegativeSurface <<?A gps:stagecount ?B>>.
    ?A list:firstRest (?C ?D).
    ?D list:firstRest (?E ?F).
    ?C log:notEqualTo ?E.
    ?D gps:stagecount ?G.
    (?G 1) math:sum ?B.
}.

(?A ?B ?C ?D) log:onNegativeSurface {
    () log:onNegativeSurface <<?A gps:stagecount ?B>>.
    ?A list:firstRest (?C ?D).
    ?D gps:stagecount ?B.
}.

# current state
:i1 :location :Gent.

# map of Belgium
(?S ?L) log:onNegativeSurface {
    () log:onNegativeSurface <<:map-BE gps:description ({?S :location :Gent} true {?S :location :Brugge} :drive_gent_brugge 1500.0 0.006 0.96 0.99)>>.
    ?S :location ?L.
}.

(?S ?L) log:onNegativeSurface {
    () log:onNegativeSurface <<:map-BE gps:description ({?S :location :Gent} true {?S :location :Kortrijk} :drive_gent_kortrijk 1600.0 0.007 0.96 0.99)>>.
    ?S :location ?L.
}.

(?S ?L) log:onNegativeSurface {
    () log:onNegativeSurface <<:map-BE gps:description ({?S :location :Kortrijk} true {?S :location :Brugge} :drive_kortrijk_brugge 1600.0 0.007 0.96 0.99)>>.
    ?S :location ?L.
}.

(?S ?L) log:onNegativeSurface {
    () log:onNegativeSurface <<:map-BE gps:description ({?S :location :Brugge} true {?S :location :Oostende} :drive_brugge_oostende 900.0 0.004 0.98 1.0)>>.
    ?S :location ?L.
}.

# path to goal state
(?SCOPE ?SUBJECT ?PATH ?DURATION ?COST ?BELIEF ?COMFORT) log:onNegativeSurface {
    ?SCOPE gps:findpath ({?SUBJECT :location :Oostende} ?PATH ?DURATION ?COST ?BELIEF ?COMFORT (5000.0 5.0 0.2 0.4 1)).
    () log:onNegativeSurface {
        ?SUBJECT gps:path (?PATH ?DURATION ?COST ?BELIEF ?COMFORT).
    }.
}.

# query
(?SUBJECT ?PATH ?DURATION ?COST ?BELIEF ?COMFORT) log:onQuerySurface {
    ?SUBJECT gps:path (?PATH ?DURATION ?COST ?BELIEF ?COMFORT).
}.
