# ----------------------------------------------
# Sequent resolution and rewriting -- Jos De Roo
# ----------------------------------------------

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix graph: <http://www.w3.org/2000/10/swap/graph#>.

# resolution A (proof by cases)
{
    ?A log:sequent ?B.
    ?B list:select (?C ?D).
    ?C => ?E.
    ?G list:firstRest (?E ?D).
} => {
    ?A log:sequent ?G.
}.

# resolution B (proof by cases)
{
    ?A log:sequent ?B.
    ?B list:select (?C ?D).
    ?C log:sequent ().
} => {
    ?A log:sequent ?D.
}.

# resolution C (modus tollens)
{
    ?A log:sequent ?B.
    ?B log:sequent ().
} => {
    ?A log:sequent ().
}.

# resolution D (modus tollens)
{
    ?A => ?B.
    ?B log:sequent ().
} => {
    ?A log:sequent ().
}.

# rewriting A (factoring)
{
    ?A log:sequent ?B.
    ?B list:removeDuplicates (?C).
} => {
    ?A => ?C.
}.

# rewriting B (contrapositive)
{
    ?A log:sequent ?B.
    ?B list:select (?C ?D).
    ({ ?C log:sequent () } ?A) graph:union ?E.
} => {
    ?E log:sequent ?D.
}.

# rewriting C (contrapositive)
{
    ?A log:sequent ().
    ?A graph:list ?B.
    ?B list:select (?C ?M).
    ?C log:isBuiltin false.
    ?E graph:list ?M.
} => {
    ?E => {
        ?C log:sequent ().
    }.
}.

# rewriting D (double negation)
{
    {
        ?A log:sequent ().
    } log:sequent ().
} => {
    true => ?A.
}.

# inference fuse
{
    ?A log:sequent ().
    ?A log:call true.
} => false.
