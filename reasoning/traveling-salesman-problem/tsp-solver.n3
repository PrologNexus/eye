@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <http://example.org/tsp#>.

# =============================================================================
# Traveling Salesman Problem Solver in N3 (for EYE Reasoner)
# Author: Jos De Roo
# License: MIT
# Description:
#   - Finds the optimal round-trip through all cities (minimal total distance)
#   - Accepts pairwise symmetric :distance triples
#   - Eliminates symmetrical (mirror/rotated) duplicates
# Dependencies:
#   - EYE reasoner: https://github.com/eyereasoner/eye
#   - Uses SWAP vocabularies: math, list, log
# Usage:
#   1. Include city distances as (:city1 :city2) :distance value .
#   2. Run with query:
#        { ?R :isOptimalPath ?L } => { ?R :isOptimalPath ?L }.
# =============================================================================

# --- Symmetric distances ---
{ (?A ?B) :distance ?C } => { (?B ?A) :distance ?C }.

# --- Derive all unique cities and sort them canonically ---
{
    (?A {?A :distance ?B} ?C) log:collectAllIn ?SCOPE.
    ?C list:append ?D.
    ?D list:removeDuplicates ?E.
    ?E list:sort ?AllCities.
} => {
    [] :allCities ?AllCities.
}.

# --- Generate round-trip permutations (ending back at starting point) ---
{
    ?X :allCities ?L.
    ?L list:permutation ?P.
    ?P list:first ?Start.
    (?P (?Start)) list:append ?Cycle.
} => {
    ?T :route ?Cycle.
}.

# --- Sum path length using backward rules ---
{ (?A ?B) :sumDistance ?D } <= {
    (?A ?B) :distance ?D.
}.

{ ?L :sumDistance ?Total } <= {
    ?L list:firstRest (?A ?Tail).
    ?Tail list:firstRest (?B ?Rest).
    (?A ?B) :distance ?D.
    ?Tail :sumDistance ?RestSum.
    (?D ?RestSum) math:sum ?Total.
}.

# --- Assign total length to each route ---
{
  ?T :route ?L.
  ?L :sumDistance ?D.
}
=> {
  ?T :totalLength ?D.
}.

# --- Determine optimal route(s) ---
{
    ?T :route ?R; :totalLength ?L.
    ?SCOPE log:notIncludes {
        ?Other :totalLength ?OL.
        ?Other log:notEqualTo ?T.
        ?OL math:lessThan ?L.
    }.
    ?R list:first ?F.
    [] :allCities ?AllCities.
    ?AllCities list:first ?F.
} => {
  ?R :isOptimalPath ?L.
}.
