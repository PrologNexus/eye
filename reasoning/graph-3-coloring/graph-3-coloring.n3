@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <http://example.org/#>.

# graph definition
:a :edge :b.
:b :edge :c.
:c :edge :d.
:d :edge :e.
:e :edge :a.
:a :edge :c.
:b :edge :d.

# list of allowed colors
true :color :red.
true :color :blue.
true :color :green.

# check if a coloring is valid for the entire graph (no two connected nodes have the same color)
true :valid_coloring ().
{ true :valid_coloring ?L } <= {
    ?L list:firstRest (?NC ?Rest).
    ({ ?NC :conflict ?Rest } false true) log:ifThenElseIn (?SCOPE -1).
    true :valid_coloring ?Rest.
}.

# conflict check: verifies if neighbors have the same color
{ (?Node ?Color) :conflict ?L } <= {
    ?L list:firstRest ((?Neighbor ?Color) ?Any).
    ?Noded :edge ?Neighbor.
}.
{ ?NC :conflict ?L } <= {
    ?L list:firstRest (?Any ?Rest).
    ?NC :conflict ?Rest.
}.

# Alice's secret valid coloring
true :alice_knows_coloring ((:a :red) (:b :blue) (:c :green) (:d :red) (:e :blue)).

# prover generates a permuted version of the coloring (hides actual colors)
{ true :permuted_coloring ?PermutedColoring } <= {
    true :alice_knows_coloring ?SecretColoring.
    ?SecretColoring list:permutation ?PermutedColoring.
}.

# verifier issues a random edge as a challenge
{ true :challenge_edge (?X ?Y) } <= {
    ?X :edge ?Y.
}.

# prover reveals colors for the challenged edge only
{ ((?X ?Y) ?PermutedColoring) :prover_response ((?X ?ColorX) (?Y ?ColorY)) } <= {
    ?PermutedColoring list:member (?X ?ColorX).
    ?PermutedColoring list:member (?Y ?ColorY).
}.

# verifier checks if revealed colors are different for the challenged edge
{ ((?X ?ColorX) (?Y ?ColorY)) :verify_response ?Result } <= {
    ({ ?ColorX log:notEqualTo ?ColorY } { ?Result log:equalTo :valid } { ?Result log:equalTo :invalid })  log:ifThenElseIn (?SCOPE -1).
}.
