# -----------------
# Superdense coding
# -----------------
#
# See https://arxiv.org/pdf/1101.3764.pdf and https://arxiv.org/pdf/1010.2929.pdf
#
# One remarkable feature of entangled states is superdense coding, whereby
# entanglement can double the information capacity of a quantum system.
# Suppose that Alice and Bob initially share a pair of mobits in the joint
# state |R). Alice can encode two bits (four possible messages) by choosing
# to apply the operators 1, G, K or KG to her mobit, resulting in one of the
# four states |R), |S), |U) or |V ). If she then delivers her transformed
# mobit to Bob, he can perform a joint measurement on both mobits to
# reliably distinguish these possibilities.
# The same set of entangled mobit states and single-mobit transformations
# can also be used to accomplish the analogue of quantum teleportation.
#
# Discrete quantum theory is obtained by instantiating the mathematical framework
# of Hilbert spaces with a finite field instead of the field of complex numbers.
# This instantiation collapses much the structure of actual quantum mechanics but
# retains several of its distinguishing characteristics including the notions of
# superposition, interference, and entanglement. Furthermore, discrete quantum
# theory excludes local hidden variable models, has a no-cloning theorem, and can
# express natural counterparts of quantum information protocols such as superdense
# coding and teleportation.
#
# Surprisingly discrete quantum computing is identical to conventional logic
# programming except for a small twist that is responsible for all the
# "quantum-ness". The twist occurs when merging sets of answers computed by
# several alternatives: the answers are combined using an exclusive version of
# logical disjunction. In other words, the two branches of a choice junction
# exhibit an interference effect: an answer is produced from the junction if it
# occurs in one or the other branch but not both.

@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix lingua: <http://www.w3.org/2000/10/swap/lingua#>.
@prefix var: <http://www.w3.org/2000/10/swap/var#>.
@prefix : <http://example.org/ns#>.

# |R) = |0, 0) + |1, 1
:FALSE :r :FALSE.
:TRUE :r :TRUE.

# |S) = |0, 1) + |1, 0
:FALSE :s :TRUE.
:TRUE :s :FALSE.

# |U) = |0, 0) + |1, 0) + |1, 1
:FALSE :u :FALSE.
:TRUE :u :FALSE.
:TRUE :u :TRUE.

# |V ) = |0, 0) + |0, 1) + |1, 0
:FALSE :v :FALSE.
:FALSE :v :TRUE.
:TRUE :v :FALSE.

# 1 |0) = |0
:FALSE :id :FALSE.
# 1 |1) = |1
:TRUE :id :TRUE.

# G |0) = |1
:FALSE :g :TRUE.
# G |1) = |0
:TRUE :g :FALSE.

# K |0) = |0
:FALSE :k :FALSE.
# K |1) = |0) + |1
:TRUE :k :FALSE.
:TRUE :k :TRUE.

# KG
:sdcoding_rule1 a lingua:BackwardRule;
    lingua:conclusion (
        var:X :kg var:Y
    );
    lingua:premise (
        var:X :g var:Z
        var:Z :k var:Y
    ).

# GK
:sdcoding_rule2 a lingua:BackwardRule;
    lingua:conclusion (
        var:X :gk var:Y
    );
    lingua:premise (
        var:X :k var:Z
        var:Z :g var:Y
    ).

# Alice
:sdcoding_rule3 a lingua:BackwardRule;
    lingua:conclusion (
        0 :alice (var:X var:Y)
    );
    lingua:premise (
        var:X :id var:Y
    ).

:sdcoding_rule4 a lingua:BackwardRule;
    lingua:conclusion (
        1 :alice (var:X var:Y)
    );
    lingua:premise (
        var:X :g var:Y
    ).

:sdcoding_rule5 a lingua:BackwardRule;
    lingua:conclusion (
        2 :alice (var:X var:Y)
    );
    lingua:premise (
        var:X :k var:Y
    ).

:sdcoding_rule6 a lingua:BackwardRule;
    lingua:conclusion (
        3 :alice (var:X var:Y)
    );
    lingua:premise (
        var:X :kg var:Y
    ).

# Bob
:sdcoding_rule7 a lingua:BackwardRule;
    lingua:conclusion (
        (var:X var:Y) :bob 0
    );
    lingua:premise (
        var:X :gk var:Y
    ).

:sdcoding_rule8 a lingua:BackwardRule;
    lingua:conclusion (
        (var:X var:Y) :bob 1
    );
    lingua:premise (
        var:X :k var:Y
    ).

:sdcoding_rule9 a lingua:BackwardRule;
    lingua:conclusion (
        (var:X var:Y) :bob 2
    );
    lingua:premise (
        var:X :g var:Y
    ).

:sdcoding_rule10 a lingua:BackwardRule;
    lingua:conclusion (
        (var:X var:Y) :bob 3
    );
    lingua:premise (
        var:X :id var:Y
    ).

# superdense coding
:sdcoding_rule11 a lingua:ForwardRule;
    lingua:premise (
        var:N :alice var:A
        var:B :bob var:M
        (
            1
            (
                var:X :r var:Y
                var:N :alice (var:X var:Z)
                (var:Z var:Y) :bob var:M
            )
            var:L
        ) log:collectAllIn var:S
        var:L list:length var:I
        (var:I 2) math:remainder 1
    );
    lingua:conclusion (
        var:N :sdcoding var:M
    ).

# query
:sdcoding_query a lingua:QueryRule;
    lingua:premise (
        var:N :sdcoding var:M
    );
    lingua:conclusion (
        () :sdcoding (var:N var:M)
    ).
