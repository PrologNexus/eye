# ------------------------------
# Goal driven Parallel Sequences
# ------------------------------
#
# Inspired by https://www.cs.cmu.edu/~fp/courses/15816-s12/lectures/01-inference.pdf
#
# [[
# In linear logic we are instead concerned with the change of truth with a
# change of state. We model this in a very simple way: when an inference rule
# is applied we consume the propositions used as premises and produce the
# propositions in the conclusions, thereby effecting an overall change in state.
# ]]
#
# See https://github.com/hongsun502/wstLogic
# Weighted state transition logic (wstLogic) for future state prediction
#
# Current adaptive systems are mostly built on detecting an event and take
# corresponding adaptations. Weighted state transition logic aims to model
# the future state, and allows to carry adaptive pathway management based
# on the predicted future state.

@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix gps: <http://eyereasoner.github.io/eye/reasoning/gps/gps-schema#>.
@prefix lingua: <http://www.w3.org/2000/10/swap/lingua#>.
@prefix var: <http://www.w3.org/2000/10/swap/var#>.
@prefix : <http://example.org/ns#>.

# find paths in the state space from initial state to goal state within limits
:gps_rule1 a lingua:BackwardRule;
    lingua:conclusion (
        () gps:findpath (var:Goal var:Path var:Duration var:Cost var:Belief var:Comfort
            (var:MaxDuration var:MaxCost var:MinBelief var:MinComfort))
    );
    lingua:premise (
        () gps:findpaths (() var:Goal () 0.0 0.0 1.0 1.0 var:Path var:Duration var:Cost var:Belief var:Comfort
            (var:MaxDuration var:MaxCost var:MinBelief var:MinComfort 1))
    ).

:gps_rule2 a lingua:BackwardRule;
    lingua:conclusion (
        () gps:findpath (var:Goal var:Path var:Duration var:Cost var:Belief var:Comfort
            (var:MaxDuration var:MaxCost var:MinBelief var:MinComfort var:MaxStagecount))
    );
    lingua:premise (
        () gps:findpaths (() var:Goal () 0.0 0.0 1.0 1.0 var:Path var:Duration var:Cost var:Belief var:Comfort
            (var:MaxDuration var:MaxCost var:MinBelief var:MinComfort var:MaxStagecount))
    ).

:gps_rule3 a lingua:BackwardRule;
    lingua:conclusion (
        () gps:findpaths (var:Maps var:Goal var:Path var:Duration var:Cost var:Belief var:Comfort var:Path var:Duration var:Cost var:Belief var:Comfort
            (var:MaxDuration var:MaxCost var:MinBelief var:MinComfort var:MaxStagecount))
    );
    lingua:premise (
        var:Goal log:call true
    ).

:gps_rule4 a lingua:BackwardRule;
    lingua:conclusion (
        () gps:findpaths (var:Maps_s var:Goal var:Path_s var:Duration_s var:Cost_s var:Belief_s var:Comfort_s var:Path var:Duration var:Cost var:Belief var:Comfort
            (var:MaxDuration var:MaxCost var:MinBelief var:MinComfort var:MaxStagecount))
    );
    lingua:premise (
        var:Map gps:description (var:From var:Transition var:To var:Action var:Duration_n var:Cost_n var:Belief_n var:Comfort_n)
        (var:Maps_s (var:Map)) list:append var:Maps_t
        var:Maps_t gps:stagecount var:Stagecount
        var:Stagecount math:notGreaterThan var:MaxStagecount
        (var:Duration_s var:Duration_n) math:sum var:Duration_t
        var:Duration_t math:notGreaterThan var:MaxDuration
        (var:Cost_s var:Cost_n) math:sum var:Cost_t
        var:Cost_t math:notGreaterThan var:MaxCost
        (var:Belief_s var:Belief_n) math:product var:Belief_t
        var:Belief_t math:notLessThan var:MinBelief
        (var:Comfort_s var:Comfort_n) math:product var:Comfort_t
        var:Comfort_t math:notLessThan var:MinComfort
        (var:Path_s (var:Action)) list:append var:Path_t
        var:From log:becomes var:To
        (
            () gps:findpaths (var:Maps_t var:Goal var:Path_t var:Duration_t var:Cost_t var:Belief_t var:Comfort_t var:Path var:Duration var:Cost var:Belief var:Comfort
                (var:MaxDuration var:MaxCost var:MinBelief var:MinComfort var:MaxStagecount))
        ) log:callWithCleanup (
            var:To log:becomes var:From
        )
    ).

# counting the number of stages (a stage is a sequence of steps in the same map)
:gps_rule5 a lingua:BackwardRule;
    lingua:conclusion (
        () gps:stagecount 1
    );
    lingua:premise true.

:gps_rule6 a lingua:BackwardRule;
    lingua:conclusion (
        var:A gps:stagecount var:B
    );
    lingua:premise (
        var:A list:firstRest (var:C var:D)
        var:D list:firstRest (var:E var:F)
        var:C log:notEqualTo var:E
        var:D gps:stagecount var:G
        (var:G 1) math:sum var:B
    ).

:gps_rule7 a lingua:BackwardRule;
    lingua:conclusion (
        var:A gps:stagecount var:B
    );
    lingua:premise (
        var:A list:firstRest (var:C var:D)
        var:D gps:stagecount var:B
    ).

# current state as practical example
:i1 :location :Gent.

# map of Belgium
:gps_rule8 a lingua:BackwardRule;
    lingua:conclusion (
        :map-BE gps:description ((var:S :location :Gent) () (var:S :location :Brugge) :drive_gent_brugge 1500.0 0.006 0.96 0.99)
    );
    lingua:premise (
        var:S :location var:L
    ).

:gps_rule9 a lingua:BackwardRule;
    lingua:conclusion (
        :map-BE gps:description ((var:S :location :Gent) () (var:S :location :Kortrijk) :drive_gent_kortrijk 1600.0 0.007 0.96 0.99)
    );
    lingua:premise (
        var:S :location var:L
    ).

:gps_rule10 a lingua:BackwardRule;
    lingua:conclusion (
        :map-BE gps:description ((var:S :location :Kortrijk) () (var:S :location :Brugge) :drive_kortrijk_brugge 1600.0 0.007 0.96 0.99)
    );
    lingua:premise (
        var:S :location var:L
    ).

:gps_rule11 a lingua:BackwardRule;
    lingua:conclusion (
        :map-BE gps:description ((var:S :location :Brugge) () (var:S :location :Oostende) :drive_brugge_oostende 900.0 0.004 0.98 1.0)
    );
    lingua:premise (
        var:S :location var:L
    ).

# query
:gps_query a lingua:QueryRule;
    lingua:premise (
        () gps:findpath ((var:SUBJECT :location :Oostende) var:PATH var:DURATION var:COST var:BELIEF var:COMFORT (5000.0 5.0 0.2 0.4 1))
    );
    lingua:conclusion (
        var:SUBJECT gps:path (var:PATH var:DURATION var:COST var:BELIEF var:COMFORT)
    ).
