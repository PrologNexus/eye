@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix rule: <http://eyereasoner.github.io/rule#>.
@prefix : <http://example.org/ns#>.

# |R) = |0, 0) + |1, 1)
:FALSE :r :FALSE.
:TRUE :r :TRUE.

# |S) = |0, 1) + |1, 0)
:FALSE :s :TRUE.
:TRUE :s :FALSE.

# |U) = |0, 0) + |1, 0) + |1, 1)
:FALSE :u :FALSE.
:TRUE :u :FALSE.
:TRUE :u :TRUE.

# |V ) = |0, 0) + |0, 1) + |1, 0)
:FALSE :v :FALSE.
:FALSE :v :TRUE.
:TRUE :v :FALSE.

# 1 |0) = |0)
:FALSE :id :FALSE.
# 1 |1) = |1)
:TRUE :id :TRUE.

# G |0) = |1)
:FALSE :g :TRUE.
# G |1) = |0)
:TRUE :g :FALSE.

# K |0) = |0)
:FALSE :k :FALSE.
# K |1) = |0) + |1)
:TRUE :k :FALSE.
:TRUE :k :TRUE.

# KG
[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
        _:Z
    );
    rule:conclusion (
        (_:X :kg _:Y)
    );
    rule:premise (
        (_:X :g _:Z)
        (_:Z :k _:Y)
    ).

# GK
[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
        _:Z
    );
    rule:conclusion (
        (_:X :gk _:Y)
    );
    rule:premise (
        (_:X :k _:Z)
        (_:Z :g _:Y)
    ).

# Alice
[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        (0 :alice (_:X _:Y))
    );
    rule:premise (
        (_:X :id _:Y)
    ).

[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        (1 :alice (_:X _:Y))
    );
    rule:premise (
        (_:X :g _:Y)
    ).

[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        (2 :alice (_:X _:Y))
    );
    rule:premise (
        (_:X :k _:Y)
    ).

[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        (3 :alice (_:X _:Y))
    );
    rule:premise (
        (_:X :kg _:Y)
    ).

# Bob
[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        ((_:X _:Y) :bob 0)
    );
    rule:premise (
        (_:X :gk _:Y)
    ).

[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        ((_:X _:Y) :bob 1)
    );
    rule:premise (
        (_:X :k _:Y)
    ).

[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        ((_:X _:Y) :bob 2)
    );
    rule:premise (
        (_:X :g _:Y)
    ).

[] a rule:BackwardRule;
    rule:graffiti (
        _:X
        _:Y
    );
    rule:conclusion (
        ((_:X _:Y) :bob 3)
    );
    rule:premise (
        (_:X :id _:Y)
    ).

# superdense coding
[] a rule:ForwardRule;
    rule:graffiti (
        _:N
        _:A
        _:B
        _:M
        _:X
        _:Y
        _:Z
        _:L
        _:S
        _:I
    );
    rule:premise (
        (_:N :alice _:A)
        (_:B :bob _:M)
        ((1 ((_:X :r _:Y) (_:N :alice (_:X _:Z)) ((_:Z _:Y) :bob _:M)) _:L) log:collectAllIn _:S)
        (_:L list:length _:I)
        ((_:I 2) math:remainder 1)
    );
    rule:conclusion (
        (_:N :sdcoding _:M)
    ).

# query
[] a rule:QueryRule;
    rule:graffiti (
        _:N
        _:M
    );
    rule:premise (
        (_:N :sdcoding _:M)
    );
    rule:conclusion (
        (_:N :sdcoding _:M)
    ).
