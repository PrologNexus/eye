@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix gps: <http://eyereasoner.github.io/eye/reasoning/gps/gps-schema#>.
@prefix rule: <http://www.w3.org/2000/10/swap/rule#>.
@prefix : <http://example.org/ns#>.

# find paths in the state space from initial state to goal state within limits
:gps_rule1 a rule:BackwardRule;
    rule:vars (
        _:Goal
        _:Path
        _:Duration
        _:Cost
        _:Belief
        _:Comfort
        _:MaxDuration
        _:MaxCost
        _:MinBelief
        _:MinComfort
    );
    rule:conclusion (
        (() gps:findpath (_:Goal _:Path _:Duration _:Cost _:Belief _:Comfort
            (_:MaxDuration _:MaxCost _:MinBelief _:MinComfort)))
    );
    rule:premise (
        (() gps:findpaths (() _:Goal () 0.0 0.0 1.0 1.0 _:Path _:Duration _:Cost _:Belief _:Comfort
            (_:MaxDuration _:MaxCost _:MinBelief _:MinComfort 1)))
    ).

:gps_rule2 a rule:BackwardRule;
    rule:vars (
        _:Goal
        _:Path
        _:Duration
        _:Cost
        _:Belief
        _:Comfort
        _:MaxDuration
        _:MaxCost
        _:MinBelief
        _:MinComfort
        _:MaxStagecount
    );
    rule:conclusion (
        (() gps:findpath (_:Goal _:Path _:Duration _:Cost _:Belief _:Comfort
            (_:MaxDuration _:MaxCost _:MinBelief _:MinComfort _:MaxStagecount)))
    );
    rule:premise (
        (() gps:findpaths (() _:Goal () 0.0 0.0 1.0 1.0 _:Path _:Duration _:Cost _:Belief _:Comfort
            (_:MaxDuration _:MaxCost _:MinBelief _:MinComfort _:MaxStagecount)))
    ).

:gps_rule3 a rule:BackwardRule;
    rule:vars (
        _:Maps
        _:Goal
        _:Path
        _:Duration
        _:Cost
        _:Belief
        _:Comfort
        _:MaxDuration
        _:MaxCost
        _:MinBelief
        _:MinComfort
        _:MaxStagecount
    );
    rule:conclusion (
        (() gps:findpaths (_:Maps _:Goal _:Path _:Duration _:Cost _:Belief _:Comfort _:Path _:Duration _:Cost _:Belief _:Comfort
            (_:MaxDuration _:MaxCost _:MinBelief _:MinComfort _:MaxStagecount)))
    );
    rule:premise (
        (_:Goal log:callWithCleanup ())
    ).

:gps_rule4 a rule:BackwardRule;
    rule:vars (
        _:Maps_s
        _:Goal
        _:Path_s
        _:Duration_s
        _:Cost_s
        _:Belief_s
        _:Comfort_s
        _:Path
        _:Duration
        _:Cost
        _:Belief
        _:Comfort
        _:MaxDuration
        _:MaxCost
        _:MinBelief
        _:MinComfort
        _:MaxStagecount
        _:Map
        _:From
        _:Transition
        _:To
        _:Action
        _:Duration_n
        _:Cost_n
        _:Belief_n
        _:Comfort_n
        _:Maps_t
        _:Stagecount
        _:Duration_t
        _:Cost_t
        _:Belief_t
        _:Comfort_t
        _:Path_t
    );
    rule:conclusion (
        (() gps:findpaths (_:Maps_s _:Goal _:Path_s _:Duration_s _:Cost_s _:Belief_s _:Comfort_s _:Path _:Duration _:Cost _:Belief _:Comfort
            (_:MaxDuration _:MaxCost _:MinBelief _:MinComfort _:MaxStagecount)))
    );
    rule:premise (
        (_:Map gps:description (_:From _:Transition _:To _:Action _:Duration_n _:Cost_n _:Belief_n _:Comfort_n))
        ((_:Maps_s (_:Map)) list:append _:Maps_t)
        (_:Maps_t gps:stagecount _:Stagecount)
        (_:Stagecount math:notGreaterThan _:MaxStagecount)
        ((_:Duration_s _:Duration_n) math:sum _:Duration_t)
        (_:Duration_t math:notGreaterThan _:MaxDuration)
        ((_:Cost_s _:Cost_n) math:sum _:Cost_t)
        (_:Cost_t math:notGreaterThan _:MaxCost)
        ((_:Belief_s _:Belief_n) math:product _:Belief_t)
        (_:Belief_t math:notLessThan _:MinBelief)
        ((_:Comfort_s _:Comfort_n) math:product _:Comfort_t)
        (_:Comfort_t math:notLessThan _:MinComfort)
        ((_:Path_s (_:Action)) list:append _:Path_t)
        (_:From log:becomes _:To)
        (((() gps:findpaths (_:Maps_t _:Goal _:Path_t _:Duration_t _:Cost_t _:Belief_t _:Comfort_t _:Path _:Duration _:Cost _:Belief _:Comfort
            (_:MaxDuration _:MaxCost _:MinBelief _:MinComfort _:MaxStagecount)))) log:callWithCleanup ((_:To log:becomes _:From)))
    ).

# counting the number of stages (a stage is a sequence of steps in the same map)
:gps_rule5 a rule:BackwardRule;
    rule:vars ();
    rule:conclusion (
        (() gps:stagecount 1)
    );
    rule:premise ().

:gps_rule6 a rule:BackwardRule;
    rule:vars (
        _:A
        _:B
        _:C
        _:D
        _:E
        _:F
        _:G
    );
    rule:conclusion (
        (_:A gps:stagecount _:B)
    );
    rule:premise (
        (_:A list:firstRest (_:C _:D))
        (_:D list:firstRest (_:E _:F))
        (_:C log:notEqualTo _:E)
        (_:D gps:stagecount _:G)
        ((_:G 1) math:sum _:B)
    ).

:gps_rule7 a rule:BackwardRule;
    rule:vars (
        _:A
        _:B
        _:C
        _:D
    );
    rule:conclusion (
        (_:A gps:stagecount _:B)
    );
    rule:premise (
        (_:A list:firstRest (_:C _:D))
        (_:D gps:stagecount _:B)
    ).

# current state as practical example
:i1 :location :Gent.

# map of Belgium
:gps_rule8 a rule:BackwardRule;
    rule:vars (
        _:S
        _:L
    );
    rule:conclusion (
        (:map-BE gps:description (((_:S :location :Gent)) () ((_:S :location :Brugge)) :drive_gent_brugge 1500.0 0.006 0.96 0.99))
    );
    rule:premise (
        (_:S :location _:L)
    ).

:gps_rule9 a rule:BackwardRule;
    rule:vars (
        _:S
        _:L
    );
    rule:conclusion (
        (:map-BE gps:description (((_:S :location :Gent)) () ((_:S :location :Kortrijk)) :drive_gent_kortrijk 1600.0 0.007 0.96 0.99))
    );
    rule:premise (
        (_:S :location _:L)
    ).

:gps_rule10 a rule:BackwardRule;
    rule:vars (
        _:S
        _:L
    );
    rule:conclusion (
        (:map-BE gps:description (((_:S :location :Kortrijk)) () ((_:S :location :Brugge)) :drive_kortrijk_brugge 1600.0 0.007 0.96 0.99))
    );
    rule:premise (
        (_:S :location _:L)
    ).

:gps_rule11 a rule:BackwardRule;
    rule:vars (
        _:S
        _:L
    );
    rule:conclusion (
        (:map-BE gps:description (((_:S :location :Brugge)) () ((_:S :location :Oostende)) :drive_brugge_oostende 900.0 0.004 0.98 1.0))
    );
    rule:premise (
        (_:S :location _:L)
    ).

# query
:gps_query a rule:QueryRule;
    rule:vars (
        _:SUBJECT
        _:PATH
        _:DURATION
        _:COST
        _:BELIEF
        _:COMFORT
    );
    rule:premise (
        (() gps:findpath (((_:SUBJECT :location :Oostende)) _:PATH _:DURATION _:COST _:BELIEF _:COMFORT (5000.0 5.0 0.2 0.4 1)))
    );
    rule:conclusion (
        (_:SUBJECT gps:path (_:PATH _:DURATION _:COST _:BELIEF _:COMFORT))
    ).
